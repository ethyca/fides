---
description: "Front-end developer rules"
alwaysApply: true
---
# Working with the front-end monorepo

While working in this `clients` directory, you are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., Ant Design, Chakra, Redux, TailwindCSS).

## Environment

- This `clients` directory is a monorepo, managed by Turborepo which is set up for the 3 main apps: admin-ui, fides-js, and privacy-center.
- The `clients/admin-ui` directory contains the Admin UI React/NextJS app
- The `clients/privacy-center` directory contains the Privacy Center React/NextJS app
- The `clients/fides-js` directory contains the Fides CMP Preact SDK, sometimes referred to as FidesJS, Fides.js, Fides SDK, or Janus. Both the Admin UI and the Privacy Center import a compiled version of the SDK.
- The `clients/fidesui` directory is a design system which exports both Chakra and Ant Design components, however we are migrating to Ant from Chakra so Ant components are always preferred if possible. Only Admin UI and Privacy center use this design system, never try to use it in fides-js code.
- The `clients/sample-app` directory is a demo app and can mostly be ignored while working in the 3 main apps.
- The rest of the codebase is considered the "backend" of fides which also gets wrapped by another repository called `fidesplus` which manages other backend code not found in this repo but is definitely utilized by the fides frontend.
- The `clients/fides-js/docs` directory gets auto-generated from the jsdocs in `clients/fides-js/src/docs` and should never be updated manually. Always add to the `clients/fides-js/src/docs` instead. The types specified in `clients/fides-js/src/docs` do get imported and used in the codebase.
- The Type definitions in the `clients/admin-ui/src/types/api` directory files get auto-generated from the fidesplus backend endpoints and should not be updated manually.
- Lazy loading scripts is not an option in FidesJS since this gets deployed on 3rd party sites as a single package and as an exported module.


## Code Implementation Guidelines

Follow these rules when you write code:
- Always prefer `try/catch` over `.then/.catch`.
- Generally prefer TS `interface` over `type` when it makes sense to do so.
- Avoid `any` types and `@ts-expect-error`, especially when it's related to the current task. Suggest ways to get the typing correct instead.
- Never omit curly braces around blocks.
- Only use tailwindcss for layout and animation classes, no colors, fonts, borders, etc.
- FidesDebugger is a global that never needs to be imported; It should never be used for error handling.
- Any time we import a Chakra component with prefix "Chakra" it has been imported "as" the suffix: For example `ChakraBox as Box`. However, as previously stated, we should not be adding Chakra components to new code. We keep those clearly marked for deprecation.
- Titles, heading text, and buttons in the HTML/JSX should be sentence-cased, not title-cased.
- When adding a property as a spread operator, favor the name `...props` over the name `...rest`
- Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator (`||` where `""` is possible, favor `??` elsewhere)

### Styling

When we’re styling components we should use this sequence of steps in this order:
1. Ant Design default theme
2. FidesUI palette colors
3. Ant Design custom theme file (which also includes some custom override colors not found in the palette)
4. global CSS variables (as a last resort when styling Ant components, should rely on the palette vars)
5. tailwindcss is used for layout and spacing only. Ant's layout components (Flex, Space, etc.) should take priority.
6. SCSS modules (for custom-component-specific styles) named after the component
7. Style prop (last resort, only when it’s not possible to style with SCSS module)

### Layout

- Use Ant’s layout components for layout and add tailwind as necessary. It’s better to wrap a component in a wrapping div or layout component than to add tailwind classes to the component itself. A scalable layout means components can come and go without tweaking the layout and if we add layout classes to the components themselves, this becomes broken.
- Avoid arbitrary sizing values (eg. min-w-[<value>])!

### Component Prop Customization

- For modifying a component prop on a global scale, create a Higher Order Component (HOC) in FidesUI with the re-exported component+prop config. These live in the `fidesui/src/hoc` directory. Use other HOC's from that directory as examples.
- For modifying a component prop for some specific instances of the component, just add the prop to each of the relevant instances without worrying too much about being DRY.
- For a truly custom component, where we are combining multiple Ant components to create something reusable, use your best judgement whether add that to the custom components in the Design System as a global component. If it seems only applicable to AdminUI, keep it in that project. Global reusable components live in the `fidesui/src/components` directory. This directory is broken down in sub-directory categories meant to mimic Ant's internal directory structure.

## Use Ant Design First, Custom Code Last

Before building anything custom, check if Ant Design already has a component for it:
- Use `<Progress>` instead of custom progress bars built from divs.
- Use `<Divider>` instead of custom CSS separators or border hacks.
- Use `<Avatar>` (with the `CustomAvatar` HOC from fidesui) for icon badges instead of building custom icon containers from styled divs.
- Use `<Row>` / `<Col>` for grid-based card layouts, not `<Flex wrap="wrap">` with manual width calculations.
- Use `<Result>` for error/empty states that need a standard layout.
- Use `<Spin>` for loading states.
- Use icons from the `Icons` export in fidesui (e.g. `<Icons.Checkmark />`) instead of inline SVG.

If you are unsure whether an Ant Design component exists for a use case, look it up before writing a custom implementation.

## Enums Over String Literals

- When the backend returns a finite set of string values (statuses, risk levels, types, etc.), define a TypeScript `enum` in the feature's `types.ts` file rather than a union type or raw strings.
- Use the enum members in all comparisons and Record keys — never compare against raw string literals.
- If autogenerated API types define a field as `string`, override it with `Omit` + your enum:
  ```typescript
  export interface MyResponse
    extends Omit<GeneratedResponse, "status"> {
    status: MyStatusEnum;
  }
  ```

## Type Safety

- Never use `any`. If a callback's argument shape is unclear, define a small interface.
- When overriding autogenerated types, use `Omit<GeneratedType, "field"> & { field: StrongerType }` to keep the rest of the generated type intact.
- Extract component prop types from Ant Design when needed: `type TextType = React.ComponentProps<typeof Typography.Text>["type"]`.

## Constants and Label Maps

- String label maps, color maps, and status-to-display mappings belong in a `constants.ts` file within the feature directory, not inline in components.
- Key these maps by enum values, not raw strings:
  ```typescript
  export const STATUS_LABELS: Record<MyStatusEnum, string> = {
    [MyStatusEnum.ACTIVE]: "Active",
    [MyStatusEnum.INACTIVE]: "Inactive",
  };
  ```

## File Organization

- **Pages** (`pages/` directory) should be thin routing shells: fetch data, handle loading/error states, compose feature components. Do not put component logic in page files.
- **Feature components** live in `features/<feature-name>/` and contain all business logic, sub-components, constants, and types for that feature.
- Split components into their own files early. If a component is more than ~40 lines, it should be its own file.
- Each feature directory should have an `index.ts` barrel file that exports its public API.
- Use relative imports (`./constants`, `./types`) within a feature directory. Use `~/` alias for cross-feature imports.

## Navigation

- Use `<NextLink href={ROUTE} passHref>` wrapping a `<Button>` for navigation, not `router.push()` in an onClick handler. This gives proper `<a>` tag semantics, prefetching, and right-click support.
- Define route constants in `features/common/nav/routes` and import them — never hardcode route strings in components.

## Default Values and Missing Data

- Do not assume defaults for missing data. If a value is nullable, show "N/A" or conditionally hide the element rather than falling back to an arbitrary default like `"low"` or `"in_progress"`.
- Use `?? null` instead of `?? "some_assumed_default"` for enum-typed fields.

## Performance

- Wrap computed values that derive from API data (filtering, mapping, grouping) in `useMemo` with proper dependency arrays.
- Avoid re-filtering or re-mapping arrays on every render.

## Error Handling

- Use `getErrorMessage()` from `~/features/common/helpers` for extracting error messages from RTK Query errors. Do not write inline `error instanceof Error ? error.message : "Unknown error"` patterns.

## Conditional Class Names

- Use the `classNames` utility (already available via fidesui) for conditional CSS classes. Do not use template string interpolation for conditional classes:
  ```typescript
  // Correct
  className={classNames(styles.card, { [styles.active]: isActive })}

  // Incorrect
  className={`${styles.card} ${isActive ? styles.active : ""}`}
  ```

## Styling: Ant Design CSS Variables

- In SCSS modules, use Ant Design CSS variable tokens (e.g. `var(--ant-border-radius-lg)`, `var(--ant-color-border)`) instead of hardcoded pixel values or colors. This keeps styles consistent with the Ant theme.
- Use fidesui palette CSS variables (e.g. `var(--fidesui-success)`) for product-specific colors.

## Inline Styles

- Avoid inline `style` props when the same result can be achieved through Ant component props (like `size`), SCSS modules, or tailwind layout classes.
- The `styles` prop on Ant components (e.g. `styles={{ body: { ... } }}`) should also be avoided — target the internal class via `:global(.ant-card-body)` in an SCSS module instead.
- When an Ant component has a `size` prop (like `Text`, `Paragraph`, `Tag`), use it instead of CSS font-size overrides.

## Unnecessary Code

- Do not generate MSW mocks, placeholder changelog entries, or boilerplate documentation files unless explicitly asked.
- Do not modify `next.config.js` unless the change is required for the feature.
- Remove dead code, unused route definitions, and unnecessary wrapper `<div>` elements. If a parent already provides the needed layout via Flex or Space, don't add an extra wrapping div.
- Do not leave verbose section-divider comments like `// ===========`. Keep comments minimal and only for non-obvious logic.

## API Queries

- Always pass explicit pagination parameters to RTK Query hooks (e.g. `{ page: 1, size: 100 }`) rather than relying on backend defaults.

## Props and Interfaces

- When building a component that wraps an HTML element or Ant component, extend the relevant prop interface (`HTMLAttributes<HTMLDivElement>`, `CardProps`, etc.) so that standard attributes like `className`, `onClick`, `data-*`, and `aria-*` are automatically supported.
- Use `...props` (not `...rest`) for the spread name.
