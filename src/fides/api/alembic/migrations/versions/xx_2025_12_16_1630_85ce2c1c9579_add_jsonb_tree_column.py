"""add jsonb tree column

Revision ID: 85ce2c1c9579
Revises: a7241db3ee6a
Create Date: 2025-12-16 16:30:52.073758

"""

import json

import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = "85ce2c1c9579"
down_revision = "a7241db3ee6a"
branch_labels = None
depends_on = None


def build_condition_tree(connection, table_name, row_id, id_column="id"):
    """Recursively build a condition tree from row-based storage.

    Args:
        connection: Database connection
        table_name: Name of the table to query
        row_id: ID of the current row
        id_column: Name of the ID column

    Returns:
        dict: Condition tree as a dictionary (ConditionLeaf or ConditionGroup format)
    """
    result = connection.execute(
        sa.text(
            f"SELECT condition_type, field_address, operator, value, logical_operator "
            f"FROM {table_name} WHERE {id_column} = :row_id"
        ),
        {"row_id": row_id},
    ).fetchone()

    if not result:
        return None

    condition_type, field_address, operator, value, logical_operator = result

    if condition_type == "leaf":
        # Parse value from JSONB if it's a string
        parsed_value = value
        if isinstance(value, str):
            try:
                parsed_value = json.loads(value)
            except (json.JSONDecodeError, TypeError):
                parsed_value = value

        return {
            "field_address": field_address,
            "operator": operator,
            "value": parsed_value,
        }

    # It's a group - get children ordered by sort_order
    children_rows = connection.execute(
        sa.text(
            f"SELECT {id_column} FROM {table_name} "
            f"WHERE parent_id = :parent_id ORDER BY sort_order"
        ),
        {"parent_id": row_id},
    ).fetchall()

    child_conditions = []
    for (child_id,) in children_rows:
        child_tree = build_condition_tree(connection, table_name, child_id, id_column)
        if child_tree:
            child_conditions.append(child_tree)

    if not child_conditions:
        return None

    return {
        "logical_operator": logical_operator,
        "conditions": child_conditions,
    }


def migrate_manual_task_conditions(connection):
    """Migrate manual_task_conditional_dependency rows to JSONB trees."""
    # Find all root conditions (parent_id IS NULL)
    root_rows = connection.execute(
        sa.text(
            "SELECT id, manual_task_id FROM manual_task_conditional_dependency "
            "WHERE parent_id IS NULL"
        )
    ).fetchall()

    for root_id, manual_task_id in root_rows:
        # Build the full tree
        tree = build_condition_tree(
            connection, "manual_task_conditional_dependency", root_id
        )

        if tree:
            # Update the root row with the full tree
            connection.execute(
                sa.text(
                    "UPDATE manual_task_conditional_dependency "
                    "SET condition_tree = :tree WHERE id = :root_id"
                ),
                {"tree": json.dumps(tree), "root_id": root_id},
            )


def migrate_digest_conditions(connection):
    """Migrate digest_condition rows to JSONB trees."""
    # Find all root conditions (parent_id IS NULL)
    root_rows = connection.execute(
        sa.text(
            "SELECT id, digest_config_id, digest_condition_type FROM digest_condition "
            "WHERE parent_id IS NULL"
        )
    ).fetchall()

    for root_id, digest_config_id, digest_condition_type in root_rows:
        # Build the full tree
        tree = build_condition_tree(connection, "digest_condition", root_id)

        if tree:
            # Update the root row with the full tree
            connection.execute(
                sa.text(
                    "UPDATE digest_condition "
                    "SET condition_tree = :tree WHERE id = :root_id"
                ),
                {"tree": json.dumps(tree), "root_id": root_id},
            )


def upgrade():
    # Step 1: Add condition_tree column to both tables
    op.add_column(
        "digest_condition",
        sa.Column(
            "condition_tree", postgresql.JSONB(astext_type=sa.Text()), nullable=True
        ),
    )
    op.add_column(
        "manual_task_conditional_dependency",
        sa.Column(
            "condition_tree", postgresql.JSONB(astext_type=sa.Text()), nullable=True
        ),
    )

    # Step 2: Migrate existing row-based trees to JSONB
    connection = op.get_bind()
    migrate_manual_task_conditions(connection)
    migrate_digest_conditions(connection)
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column("manual_task_conditional_dependency", "condition_tree")
    op.drop_column("digest_condition", "condition_tree")
    # ### end Alembic commands ###
