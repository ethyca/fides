# pylint: disable=R0401, C0302

from __future__ import annotations

from typing import Optional

from sqlalchemy import Column, DateTime, String
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.ext.mutable import MutableList
from sqlalchemy.sql import text

from fides.api.db.base_class import Base  # type: ignore[attr-defined]
from fides.api.db.util import EnumColumn
from fides.api.schemas.policy import ActionType, CurrentStep
from fides.api.schemas.privacy_request import ExecutionLogStatus

# Locations from which privacy request execution can be resumed, in order.
EXECUTION_CHECKPOINTS = [
    CurrentStep.pre_webhooks,
    CurrentStep.access,
    CurrentStep.upload_access,
    CurrentStep.erasure,
    CurrentStep.finalize_erasure,
    CurrentStep.consent,
    CurrentStep.finalize_consent,
    CurrentStep.email_post_send,
    CurrentStep.post_webhooks,
]

COMPLETED_EXECUTION_LOG_STATUSES = [
    ExecutionLogStatus.complete,
    ExecutionLogStatus.skipped,
]

EXITED_EXECUTION_LOG_STATUSES = [
    ExecutionLogStatus.complete,
    ExecutionLogStatus.error,
    ExecutionLogStatus.skipped,
]


def can_run_checkpoint(
    request_checkpoint: CurrentStep, from_checkpoint: Optional[CurrentStep] = None
) -> bool:
    """Determine whether we should run a specific checkpoint in privacy request execution

    If there's no from_checkpoint specified we should always run the current checkpoint.
    """
    if not from_checkpoint:
        return True
    return EXECUTION_CHECKPOINTS.index(
        request_checkpoint
    ) >= EXECUTION_CHECKPOINTS.index(from_checkpoint)


class ExecutionLog(Base):
    """
    Stores the individual execution logs associated with a PrivacyRequest.

    Execution logs contain information about the individual queries as they progress through the workflow
    generated by the query builder.
    """

    connection_key = Column(String, index=True)
    # Name of the fides-annotated dataset, for example: my-mongo-db
    dataset_name = Column(String, index=True)
    # Name of the particular collection or table affected
    collection_name = Column(String, index=True)
    # A JSON Array describing affected fields along with their data categories and paths
    fields_affected = Column(MutableList.as_mutable(JSONB), nullable=True)
    # Contains info, warning, or error messages
    message = Column(String)
    action_type = Column(
        EnumColumn(ActionType),
        index=True,
        nullable=False,
    )
    status = Column(
        EnumColumn(
            ExecutionLogStatus,
            native_enum=True,
            values_callable=lambda x: [
                i.value for i in x
            ],  # Using ExecutionLogStatus values in database, even though app is using the names.
        ),
        index=True,
        nullable=False,
    )

    privacy_request_id = Column(
        String,
        nullable=False,
        index=True,
    )

    # Use clock_timestamp() instead of NOW() to get the actual current time at row creation,
    # regardless of transaction state. This prevents timestamp caching within transactions
    # and ensures more accurate creation times.
    # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT

    created_at = Column(
        DateTime(timezone=True), server_default=text("clock_timestamp()")
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=text("clock_timestamp()"),
        onupdate=text("clock_timestamp()"),
    )
