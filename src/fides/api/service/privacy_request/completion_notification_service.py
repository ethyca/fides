from datetime import datetime, timedelta
from typing import Any, Optional

from loguru import logger
from sqlalchemy.orm import Session

from fides.api.common_exceptions import IdentityNotFoundException
from fides.api.db.session import get_db_session
from fides.api.models.policy import Policy
from fides.api.models.privacy_request import PrivacyRequest, ProvidedIdentityType
from fides.api.models.privacy_request.webhook import (
    generate_privacy_request_download_token,
)
from fides.api.schemas.messaging.messaging import (
    AccessRequestCompleteBodyParams,
    MessagingActionType,
)
from fides.api.schemas.policy import ActionType
from fides.api.schemas.privacy_request import PrivacyRequestStatus
from fides.api.schemas.redis_cache import Identity
from fides.api.schemas.storage.storage import StorageType
from fides.api.service.messaging.message_dispatch_service import dispatch_message
from fides.api.tasks.scheduled.scheduler import scheduler
from fides.common.api.v1.urn_registry import PRIVACY_CENTER_DSR_PACKAGE
from fides.config import CONFIG
from fides.config.config_proxy import ConfigProxy


def initiate_consent_request_completion_email(
    session: Session,
    identity_data: dict[str, Any],
    property_id: Optional[str],
) -> bool:
    """
    Send consent request completion email to the user.

    :param session: SQLAlchemy Session
    :param identity_data: Dict of identity data
    :param property_id: Property id associated with the privacy request
    :return: True if an email was sent, False if skipped due to missing email
    """
    config_proxy = ConfigProxy(session)
    email = identity_data.get(ProvidedIdentityType.email.value)

    if not email:
        # Consent requests can be submitted with only fides_user_device_id or external_id,
        # which don't have an email to send a completion message to.
        # This is not an error - just skip sending the completion email.
        logger.info("Skipping consent completion email: no email in identity data")
        return False

    to_identity: Identity = Identity(email=email)
    dispatch_message(
        db=session,
        action_type=MessagingActionType.PRIVACY_REQUEST_COMPLETE_CONSENT,
        to_identity=to_identity,
        service_type=config_proxy.notifications.notification_service_type,
        message_body_params=None,
        property_id=property_id,
    )
    return True


def initiate_privacy_request_completion_email(
    session: Session,
    policy: Policy,
    access_result_urls: list[str],
    identity_data: dict[str, Any],
    property_id: Optional[str],
    privacy_request_id: str,
) -> None:
    """
    :param session: SQLAlchemy Session
    :param policy: Policy
    :param access_result_urls: list of urls generated by access request upload
    :param identity_data: Dict of identity data
    :param property_id: Property id associated with the privacy request
    :param privacy_request_id: ID of the privacy request for generating DSR package links
    """
    config_proxy = ConfigProxy(session)
    if not (
        identity_data.get(ProvidedIdentityType.email.value)
        or identity_data.get(ProvidedIdentityType.phone_number.value)
    ):
        raise IdentityNotFoundException(
            "Identity email or phone number was not found, so request completion message could not be sent."
        )
    to_identity: Identity = Identity(
        email=identity_data.get(ProvidedIdentityType.email.value),
        phone_number=identity_data.get(ProvidedIdentityType.phone_number.value),
    )
    if policy.get_rules_for_action(action_type=ActionType.access):
        # Check if any rule has enable_access_package_redirect=True and enable_streaming=True in storage config
        # This can be extended to other storage types and non streaming access results in the future
        use_dsr_package_links = False
        for rule in policy.get_rules_for_action(action_type=ActionType.access):
            storage_destination = rule.get_storage_destination(session)
            if (
                storage_destination.type == StorageType.s3
                and storage_destination.details.get("enable_access_package_redirect")
                and storage_destination.details.get("enable_streaming")
            ):
                use_dsr_package_links = True
                break

        # Generate appropriate URLs based on streaming configuration
        if use_dsr_package_links and config_proxy.privacy_center.url:
            # Use DSR package links instead of direct storage URLs
            # Generate the download token for security
            download_token = generate_privacy_request_download_token(privacy_request_id)

            # Generate DSR package URLs for the messaging template system
            dsr_package_url = f"{config_proxy.privacy_center.url}/api{PRIVACY_CENTER_DSR_PACKAGE.format(privacy_request_id=privacy_request_id)}?token={download_token}"
            download_links = [dsr_package_url]
        else:
            # Use original direct storage URLs
            download_links = access_result_urls

        # synchronous for now since failure to send complete emails is fatal to request
        dispatch_message(
            db=session,
            action_type=MessagingActionType.PRIVACY_REQUEST_COMPLETE_ACCESS,
            to_identity=to_identity,
            service_type=config_proxy.notifications.notification_service_type,
            message_body_params=AccessRequestCompleteBodyParams(
                download_links=download_links,
                subject_request_download_time_in_days=CONFIG.security.subject_request_download_link_ttl_seconds
                / 86400,
            ),
            property_id=property_id,
        )
    if policy.get_rules_for_action(action_type=ActionType.erasure):
        dispatch_message(
            db=session,
            action_type=MessagingActionType.PRIVACY_REQUEST_COMPLETE_DELETION,
            to_identity=to_identity,
            service_type=config_proxy.notifications.notification_service_type,
            message_body_params=None,
            property_id=property_id,
        )


def initiate_paused_privacy_request_followup(privacy_request: PrivacyRequest) -> None:
    """Initiates scheduler to expire privacy request when the redis cache expires"""
    scheduler.add_job(
        func=mark_paused_privacy_request_as_expired,
        kwargs={"privacy_request_id": privacy_request.id},
        id=privacy_request.id,
        replace_existing=True,
        trigger="date",
        run_date=(datetime.now() + timedelta(seconds=CONFIG.redis.default_ttl_seconds)),
    )


def mark_paused_privacy_request_as_expired(privacy_request_id: str) -> None:
    """Mark "paused" PrivacyRequest as "errored" after its associated identity data in the redis cache has expired."""
    SessionLocal = get_db_session(CONFIG)
    db = SessionLocal()
    privacy_request = (
        PrivacyRequest.query_without_large_columns(db)
        .filter(PrivacyRequest.id == privacy_request_id)
        .first()
    )
    if not privacy_request:
        logger.info(
            "Attempted to mark as expired. No privacy request with id '{}' found.",
            privacy_request_id,
        )
        db.close()
        return
    if privacy_request.status == PrivacyRequestStatus.paused:
        error_message = "Privacy request has expired. Please resubmit information."
        logger.error(
            "Privacy request '{}' has expired. Please resubmit information.",
            privacy_request.id,
        )
        privacy_request.add_error_execution_log(
            db,
            connection_key=None,
            dataset_name="Privacy request processing",
            collection_name=None,
            message=error_message,
            action_type=privacy_request.policy.get_action_type(),  # type: ignore
        )
        privacy_request.error_processing(db=db)
    db.close()
